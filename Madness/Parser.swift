//  Copyright (c) 2014 Rob Rix. All rights reserved.

// Swift has no way to resolve to `Result.Result` inside `Parser.Result`.
public typealias ParserResult<C: Collection, Tree> = Result<(Tree, SourcePos<C.Index>), Error<C.Index>>

/// Convenience for describing the types of parser combinators.
///
/// \param Tree  The type of parse tree generated by the parser.
public enum Parser<C: Collection, Tree> {
	/// The type of parser combinators.
	public typealias Function = (C, SourcePos<C.Index>) -> Result

	/// The type produced by parser combinators.
	public typealias Result = ParserResult<C, Tree>
}

/// Parses `input` with `parser`, returning the parse trees or `nil` if nothing could be parsed, or if parsing did not consume the entire input.
public func parse<C: Collection, Tree>(_ parser: Parser<C, Tree>.Function, input: C) -> Result<Tree, Error<C.Index>> {
	let result = parser(input, SourcePos(index: input.startIndex))
	
	return result.flatMap { tree, sourcePos in
		return sourcePos.index == input.endIndex
			? .success(tree)
			: .failure(.leaf("finished parsing before end of input", sourcePos))
	}
}

public func parse<Tree>(_ parser: Parser<String.CharacterView, Tree>.Function, input: String) -> Result<Tree, Error<String.Index>> {
	return parse(parser, input: input.characters)
}

// MARK: - Terminals

/// Returns a parser which never parses its input.
public func none<C: Collection, Tree>(_ string: String = "no way forward") -> Parser<C, Tree>.Function {
	return { _, sourcePos in .failure(.leaf(string, sourcePos)) }
}

// Returns a parser which parses any single character.
public func any<C: Collection>(_ input: C, sourcePos: SourcePos<C.Index>) -> Parser<C, C.Element>.Result {
	return satisfy { _ in true }(input, sourcePos)
}

public func any(_ input: String.CharacterView, sourcePos: SourcePos<String.Index>) -> Parser<String.CharacterView, Character>.Result {
	return satisfy { _ in true }(input, sourcePos)
}


/// Returns a parser which parses a `literal` sequence of elements from the input.
///
/// This overload enables e.g. `%"xyz"` to produce `String -> (String, String)`.
public prefix func % <C: Collection> (literal: C) -> Parser<C, C>.Function where C.Element: Equatable {
	return { input, sourcePos in
		if input[sourcePos.index...].starts(with: literal) {
			return .success((literal, sourcePos.advanced(by: literal.count, from: input)))
		} else {
			return .failure(.leaf("expected \(literal)", sourcePos))
		}
	}
}

public prefix func %(literal: String) -> Parser<String.CharacterView, String>.Function {
	return { input, sourcePos in
		if input[sourcePos.index...].starts(with: literal.characters) {
			return .success((literal, sourcePos.advanced(by: literal, from: input)))
		} else {
			return .failure(.leaf("expected \(literal)", sourcePos))
		}
	}
}

/// Returns a parser which parses a `literal` element from the input.
public prefix func % <C: Collection> (literal: C.Element) -> Parser<C, C.Element>.Function where C.Element: Equatable {
	return { input, sourcePos in
		if sourcePos.index != input.endIndex && input[sourcePos.index] == literal {
			return .success((literal, sourcePos.advanced(by: 1, from: input)))
		} else {
			return .failure(.leaf("expected \(literal)", sourcePos))
		}
	}
}


/// Returns a parser which parses any character in `range`.
public prefix func %(range: ClosedRange<Character>) -> Parser<String.CharacterView, String>.Function {
	return { (input: String.CharacterView, sourcePos: SourcePos<String.Index>) in
		let index = sourcePos.index
		
		if index < input.endIndex && range.contains(input[index]) {
			let string = String(input[index])
			return .success((string, sourcePos.advanced(by: 1, from: input)))
		} else {
			return .failure(.leaf("expected an element in range \(range)", sourcePos))
		}
	}
}


// MARK: - Nonterminals

private func memoize<T>(_ f: @escaping () -> T) -> () -> T {
	var memoized: T!
	return {
		if memoized == nil {
			memoized = f()
		}
		return memoized
	}
}

public func delay<C: Collection, T>(_ parser: @escaping () -> Parser<C, T>.Function) -> Parser<C, T>.Function {
	let memoized = memoize(parser)
	return { memoized()($0, $1) }
}

// Returns a parser that satisfies the given predicate
public func satisfy(_ pred: @escaping (Character) -> Bool) -> Parser<String.CharacterView, Character>.Function {
	return tokenPrim(pred) { $0.advanced(by: $1, from: $2) }
}

// Returns a parser that satisfies the given predicate
public func satisfy<C: Collection> (_ pred: @escaping (C.Element) -> Bool) -> Parser<C, C.Element>.Function {
	return tokenPrim(pred) { $0.advanced(by: 1, from: $2) }
}

public func tokenPrim<C: Collection> (_ pred: @escaping (C.Element) -> Bool, _ nextPos: @escaping (SourcePos<C.Index>, C.Element, C) -> SourcePos<C.Index>) -> Parser<C, C.Element>.Function {
	return { input, sourcePos in
		let index = sourcePos.index
		if index != input.endIndex {
			let parsed = input[index]
			
			if pred(parsed) {
				return .success((parsed, nextPos(sourcePos, parsed, input)))
			} else {
				return .failure(Error.leaf("Failed to parse \(String(describing: parsed)) with predicate at index", sourcePos))
			}
		} else {
			return .failure(Error.leaf("Failed to parse at end of input", sourcePos))
		}
	}
}


// MARK: - Operators

/// Map operator.
infix operator --> : ChainingPrecedence


/// Literal operator.
prefix operator %


// MARK: - Imports

import Result
